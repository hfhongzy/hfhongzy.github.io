{"posts":[{"title":"CMU-15545 Notes","text":"15-445/645 C++ Bootcamp std::move casts a lvalue reference T &amp;x to a rvalue reference T &amp;&amp;x. If it is accepted by an lvalue, its ownership is transferred to the lvalue. Or we could just store the rvalue reference. 12345std::vector&lt;int&gt; a = {1, 2, 3};std::vector&lt;int&gt; b = std::move(a);// &quot;a&quot; becomes emptystd::vector&lt;int&gt; &amp;&amp;c = std::move(b);// &quot;b&quot; has not changed Stack unwinding, RAII (Resource Allocation Is Initialization), and wrapper classes std::shared_ptr has a member .use_count() to keep track of the number of references to the object std::mutex 123456std::mutex m;void work() { m.lock(); // critical section m.unlock();} std::scoped_lock 123456std::mutex m;void work() { std::scoped_lock slk(m); // critical section // mutex m is released.} std::conditional_variable 123456789101112131415int count = 0;std::mutex m;std::condition_variable cv;void producer() { std::scoped_lock slk(m); if (count == 2) { cv.notify_one(); }}void comsumer() { std::unique_lock lk(m); cv.wait(lk, []{ return count == 2; }); std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; std::endl;} rwlock implementation 123456789101112int count = 0;std::shared_mutex m;void read_value() { std::shared_lock lk(m); std::cout &lt;&lt; &quot;Reading value &quot; + std::to_string(count) + &quot;\\n&quot; &lt;&lt; std::flush;}void write_value() { std::unique_lock lk(m); count += 3;}","link":"/2024/07/11/CMU-15545/"},{"title":"About","text":"‚≠êÔ∏èHi! I am Hong Zhaoyang, a third-year undergraduate from the Southern University of Science and Technology (SUSTech) in Shenzhen, China. I am currently conducting research on vector databases (VDB) for large language models (LLMs) in the SUSTech DBGroup under the guidance of Prof. Bo Tang. I plan to apply for a CS PhD program for admission in Fall 2026. I have a keen interest in system design and mechanisms. I also enjoy socializing and collaborating with others. Awards 2022-2023: 47th ICPC (International College Programming Contest) World Finalist (Top 1%) (Qualification Regional) 2023-2024: 9th CCPC (Chinese College Programming Contest) Regional 2-nd runner-up (Scoreboard) 2024: SIGMOD Programming Contest World Finalist (Dashboard) See more repetitive awards here Publications Yangshen Deng, Shiwen Chen, Zhaoyang Hong, Bo Tang. How Does Software Prefetching Work on GPU Query Processing? 20th International Workshop on Data Management on New Hardware (DaMoN), affiliated with SIGMOD , Santiago, Chile, June 2024. Experiences Student Assistant of CS209 Introduction to Java Programming, Fall 2023 Student Assistant of CS203 Data Structures and Algorithm Analysis, Fall 2024 (English-speaking, Ongoing) Student Coach of SUSTech-CPC Competition Team, 2022-2023 Problem Setter and Organizer of 2023 SUSTech Programming Competition (Involving 200+ participants from 10+ schools) Instructor of the Voluntary Courses in Olympic in Informatics (OI) for The High school Affiliated to Southern University of Science and Technology (HSAS), 2023 Summer Instructor of X-Camp Summer Camp, 2024 Summer (Hangzhou, China)","link":"/2024/07/11/About/"},{"title":"Artificial Intelligence (H) Sample Paper","text":"Sample Paper: Artificial Intelligence (H), Bo Yuan True or False. On a graph where each edge is at least \\(\\epsilon\\): Greedy Search is optimal. BFS is optimal. UCS is optimal. If we use A* with the heuristic \\(h_2(n)\\), where \\(h_2(n) = 2\\cdot h(n)\\) and \\(h(n)\\) is admissible: This A* is optimal. Answer(A*) \\(\\le 2 \\times\\) optimal answer. Alpha-Beta Pruning. You are given a tree. Mark the pruned branches. The decision of the root. The alpha and beta values of the root. Constraints Satisfaction Problem (CSP). You are given a map like that in lecture slides. Cross out some values by Forward Checking. Cross out some values by AC-3 (arc-consistency). Which variables can be chosen, using MRV (Minimize Remaining Value) strategy? Logic. Formalize five statements statements into propositional logic. Convert to CNF. Describe the steps for DPLL on this CNF. Confusion Matrix. Given \\(n=10,d=2\\) \\(x_i\\)s and \\(y_i\\in \\{+1,-1\\}\\). \\(w=[1,2]\\) is fixed, but \\(b\\) is unknown. List all possible pairs of (Precision, Specificity). (Formula is given.) Decision Tree. Give \\(n=10\\) samples, with attributes: is green or not, tall or short, smelly or not, two or three legs. Classify into Alien or Human. Draw the decision tree of the sample above. Describe the rule to identify Alien (e.g. If (Green = Y and ...) .. Else If (..)) Find a CNF to identify the Alien, which is correct on the dataset. Each clause has exactly two literals. Given \\(n\\) examples \\((x_i, y_i)\\), where \\(x_i\\) is d-dimension, \\(y_i \\in \\{-1,+1\\}\\)Gradient Descent with the loss function \\(L(z) = e^{-z}\\), where \\(z = f(x_i)y_i\\). Explain why can \\(L\\) be used for the loss function. Give \\(\\Delta w\\) for a single sample point in stochastic gradient descent. Give \\(\\Delta w\\) for gradient descent. Explain the relationship between the complexity and the bias and variance of a model. For a low-bias and high-variance algorithm, which should be used, boosting or bagging, and why? Briefly describe the similarities and differences between bagging and boosting. Naive Bayes is not a good choice for bagging. Explain the reasons. Random forest, as a variant of bagging, is usually faster than bagging. Explain the reasons.","link":"/2024/09/22/AI-Exam/"}],"tags":[],"categories":[],"pages":[{"title":"","text":"SUSTech-Vichy (with Li Haoyu, Chen Luyao) 2022 ICPC Asia Xi'an Regional Contest Gold (qualified for World Final) 2022 ICPC Asia Nanjing Regional Contest Gold 2022 CCPC Guilin Regional Contest Gold SUSTech-Helsinki (with Feng Zhaohang, He Yujun) 2023 ICPC Asia Xi'an Regional Contest Gold 2023 ICPC Asia Hangzhou Regional Contest Gold 2023 CCPC Harbin Regional Contest Gold 2023 CCPC Guilin Regional Contest Gold (2nd runner-up) 2023 ICPC Asia-East Continent Final Contest Silver Personal 2022 SUSTech Programming Contest First Prize 2022 Shenzhen Technology University Programming Contest First Prize 2022 Shenzhen University Programming Contest Second Place","link":"/competitions/index.html"},{"title":"Gallery","text":"I engaged in the proposition and led the organization of the 2023 SUSTech Programming Contest (involving over 200 participants). I provided Olympic in Informatics (OI) courses for the High school Affiliated to Southern University of Science and Technology. I performed as a classical guitarist in our band at the campus Starry Sky Concert, playing Hotel California. Do you like this classic English song? SUSTech-Vichy team attended ICPC World Finals 2023 in Luxor, Egypt. SUSTech-Helsinki team won the first regional trophy üèÜ for SUSTech. A photo with Mike Mirzayanov, the founder of Codeforces. VLDB2024 (Guangzhou)","link":"/gallery/index.html"},{"title":"2024 Fall - Data Structures and Algorithms Analysis Tutorials","text":"Lab 8E Sum You are given a \\(n\\times m\\) matrix. Take out some non-adjacent numbers and maximize their summation. Let's first take a look at a classic search-and-backtrack model. Task: Generate all permutations of length \\(n\\). Sample Input 13 Sample Output 1234561 2 31 3 22 1 32 3 13 1 23 2 1 Idea: Enumerate. If \\(n=3\\), you can use \\(3\\) nested for-loops and a visited array to simplify your code. 1234567891011121314151617181920boolean visited[] = new boolean [4];for (int a1 = 1; a1 &lt;= 3; a1 ++) { if (!vis[a1]) { vis[a1] = true; for (int a2 = 1; a2 &lt;= 3; a2 ++) { if (!vis[a2]) { vis[a2] = true; for (int a3 = 1; a3 &lt;= 3; a3 ++) { if (!vis[a3]) { vis[a3] = true; // print [a1 a2 a3] vis[a3] = false; } } vis[a2] = false; } } vis[a1] = false; }} But you'd better don't code like this; it is stupid: 12345if (n == 1) { /*...*/ }if (n == 2) { /*...*/ }if (n == 3) { /*...*/ }if (n == 4) { /*...*/ }// ... So instead we can use recursion. 12345678910111213141516171819202122232425262728boolean []visited = new boolean visited[n + 1];int []a = new int a[n + 1];static int n;public static void search(int x) { // a[1], a[2], ..., a[x-1] has been filled if (x == n + 1) { for (int i = 1; i &lt;= n; i ++) { System.out.printf(&quot;%d &quot;, a[i]); } System.out.printf(&quot;\\n&quot;); return ; } for (int i = 1; i &lt;= n; i ++) { if (!visited[i]) { a[x] = i; visited[i] = true; // mark number i as &quot;used&quot; search(i + 1); // recurse visited[i] = false; // backtrack } }}public static void main(String args[]) { // program start here n = 5; search(1);} After you know this basic mechanism, you can finish this problem. The code is like 123456789101112131415161718192021222324252627282930313233boolean [][]chosen;int answer;public static void search(int x, int y, int sum) { // an additional variable (the sum of all chosen elements) if (x == n + 1 &amp;&amp; y == 1) { if (answer &lt; sum) answer = sum; return ; } // don't choose (x, y): if (y == m) { search(x + 1, 1, sum); // start a new line } else { search(x, y + 1, sum); // next element in this row } // choose (x, y): if (!chosen[x-1][y] &amp;&amp; !chosen[x-1][y-1] &amp;&amp; !chosen[x][y-1]) { // the neighbors that have been decided to be chosen or not must not be selected chosen[x][y] = true; if (y == m) { search(x + 1, 1, sum + a[x][y]); // start a new line } else { search(x, y + 1, sum + a[x][y]); // next element in this row } chosen[x][y] = false; // don't forget to backtrack }}// main:search(1, 1, 0);// print(answer); Lab4E Magic Number: By Zhang Shuwei Problem Description Build a Cartesian tree. (Note that in this problem the root is the maximum) (To learn more about Cartesian tree: https://en.wikipedia.org/wiki/Cartesian_tree) Solution An intuitive approach: Find the maximum value and partition current interval into two half, recursively solve the sub problem. Each time we solves a sub problem, either a left / right child of current node is found. For sequence \\(\\{3, 5, 1, 4, 2\\}\\): Find the maximum \\(5\\) in interval \\([1,5]\\), and recursively deal with interval \\([1,1]\\) and \\([3, 5]\\). For \\([1, 1]\\), \\(3\\) is the maximum. For \\([3, 5]\\), \\(4\\) is the maximum, recursively deal with interval \\([3, 3]\\) and \\([5, 5]\\). ... Finally, we complete the construction. This approach requires an efficient method to find the interval maximum, which is also called RMQ (Range Maximum / Minimum query, https://en.wikipedia.org/wiki/Range_minimum_query) problem. There are some classic algorithms, for example, the sparse table with \\(O(n\\log n)\\) preprocessing and \\(O(1)\\) answering time complexity and \\(O(n\\log n)\\) space complexity. However, we need a more efficient (and also far more simple) algorithm to solve the problem. Let's consider a simplified problem: Given a sequence \\(\\{a_n\\}\\), for each element, find the largest element to the left that is smaller than it. The first observation is that: If \\(i &lt; j\\) and \\(a_i &lt; a_j\\), then \\(a_i\\) can never contribute to the elements to the right of \\(a_j\\). Thus, for position \\(k\\), the only possible results of \\(k\\) must belong to a decreasing sequence \\({a_{p_1}, ...,a_{p_l}}\\), where \\(1\\leq p_1 &lt; ... &lt;p_l &lt;k\\), \\(a_{p_1}\\gt a_{p_2} ... &gt; a_{p_l}\\). Besides, each element in the sequence must be a suffix maximum of \\(a_1...a_{k-1}\\). (Otherwise, it cannot contribute to \\(a_k\\) since there is a larger one on its right). Suppose we have maintained such a sequence before \\(k\\), to get the answer for \\(k\\) and maintain the sequence, let consider the following two situation: If \\(a_{p_l} &lt; a_k\\), \\(a_{p_l}\\) might be the answer for \\(k\\), and we need to delete \\(a_{p_l}\\) from the sequence since \\(a_k &gt; a_{p_l}\\) and \\(k &gt; p_l\\). If \\(a_{p_l} &gt; a_k\\), elements before \\(a_{p_l}\\) cannot contribute to \\(k\\) and we stop here. We repeatedly move away the last element of the sequence until it is greater than \\(a_k\\), and the last removed element is \\(k\\)'s answer.' Finally, we append \\(a_k\\) to the sequence, since now \\(a_k\\) is a suffix maximum. Reviewing the entire process, can you now figure out what the \"decreasing sequence\" is? It is a stack! Actually, this data structure is called Monotonic Stack, a stack whose elements are either increasing or decreasing. We can implement the core process using simply stack's operation: push and pop. 1234567for (int i = 1; i &lt;= n; i++) { if (!stk.empty() &amp;&amp; A[i] &gt; A[stk.top()]) { l[i] = stk.top(); stk.pop(); } stk.push(i);} Finding the right child can be solved by scanning the sequence from right to left. (In fact, only one scanning from left to right is enough, think about how to implement) Since one element will be pushed into and popped from the stack at most once, the time complexity is \\(O(n)\\). lab4F Fencing Hall: By Zhang Shuwei The core idea of the problem is to keep track of the maximum/minimum of a sliding window using monotonic queue. Consider a sliding window \\([l,r]\\), if the left boundary is fixed, when we move the right boundary, the difference of the maximum and minimum in the interval may increase. Hence we need to adjust the left boundary as we moving the right boundary forward such that the difference is within the given range \\(k\\). For simplicity, we only consider the case of the maximum value. As we slide the window, we use a queue to maintain a decreasing sub-sequence in which each element is a suffix maximum of the window (similar to that in the previous problem). Suppose we now move the right boundary from \\(r\\) to \\(r+1\\): We repeatedly pop the last element of the queue until the queue is empty or the tail is larger than \\(a_{r + 1}\\). Then we append \\(a_{r + 1}\\) to the queue. The maximum of the window is the value of the queue's first element. To satisfy the difference limitation, we may also move the left boundary forward, during which we must pop the queue's front elements that are no longer in the window. The reason that we can discard the queue's last element if it is smaller than current element $a_{r + 1} $is similar to that in the previous problem, that \\(a_{r + 1}\\) will dominate the queue's tail in the following moves. Implementation details are left as exercise. \\(d(X^2) = dX\\cdot X+X\\cdot dX\\) Lab3D Converted Vinux input In this problem, you need to implement a one-line editor. The idea of using the bidirectional linked list is straightforward. 1234class Node { public char ch; public Node left, right;}; Hint: EOF is represented by -1. You can preserve this convention. Also, maintain some additional pointers, pointing to the head node, tail node (EOF), and current node. 1Node hd, tl, current; r: next single input would replace the current character; You could immediately read the next character and replace the character of the current node with the new one. Please note that the EOL will revive immediately at the end of the line whenever it vanishes! So if the current node is EOF, you should first create a new EOF, adjacent to the right of the current node, before (or, after) replacing the current character. Don't forget to update bk. I: move the character pointer to the head of the line; 1current = hd; H: left shift the current character pointer unless it is at the leftmost place; 123if (current != hd) { current = current.left;} L: right shift the current character pointer unless it is at the rightmost place; Similar to H. x: delete the current character; If the current character is not EOF, simply remove it from the linked list. 1234Node L = current.left;Node R = current.right;L.right = R;R.left = L; If the current character is EOF, just do nothing. Lab3E From-now-on minimum difference Prerequisite: Monotonic Stack. Task: Given a sequence \\(a_1,...,a_n\\). Find \\(r_i = \\min_{j&gt;i,a_j&gt;a_i} j\\) for every \\(i\\) in \\(\\mathcal O(n)\\). Think about finding the minimum \\(a_j\\) such that \\(j &gt; i\\) and \\(a_j \\ge a_i\\). The opposite \\(a_j\\le a_i\\) is similar. Hint: I suggest you write a function (or method) and call it twice. Before the second call, transform \\(a_i\\) to \\(-a_i\\). This will reverse the numerical order. Update: An alternative to calling twice is to check the left neighbor and the right neighbor. (I complicated it again) Firstly, we sort all the numbers \\(a_1, a_2, \\ldots, a_n\\) into \\(b_1 \\le b_2 \\le \\cdots \\le b_n\\). Then let \\(p_i\\) denote that \\(a_i\\) maps to \\(b[p_i]\\). Next, construct a bidirectional linked list: \\(b_1 \\leftrightarrow b_2 \\leftrightarrow b_3 \\leftrightarrow \\cdots \\leftrightarrow b_n\\). Now, we erase \\(a_1, a_2, \\ldots, a_n\\) from the list one by one. Specifically, when erasing \\(a_i\\), we are actually erasing \\(b[p_i]\\) from the list. Before erasing, we first get the right neighbor of \\(b[p_i]\\) - it is the answer for \\(a_i\\) (not-yet erased means \"to the right\", and the sorted values imply the \"smallest\"). Think about the correctness by yourself. It is really a smart method! Lab3F Peggy hates decreasing There will be multiple rounds of deletion. If we can precisely identify the elements to delete in each round, the total complexity will be \\(\\mathcal{O}(n)\\), as each element is examined (or deleted) at most once. To facilitate fast deletion, we construct a linked list. Initially, the elements \\(a_1, a_2, \\dots, a_n\\) are linked together. In the first round, a for-loop is used to find the elements that need to be erased. 12345for (int i = 1; i &lt;= n; i ++) { if (a[i] is decreasing) { Q1.push(node[i]); }} Starting from the second round, the deletion queue can be derived from the previous round's queue, based on the following observation: If an element is not \"decreasing\" initially and neither of its neighbors has been deleted now, it remains \"non-decreasing\". Now, suppose we are deleting elements \\(x\\) (in the linked list) one by one from the queue \\(Q_x\\). After removing \\(x\\), we add its neighbors x.left and x.right to a \"candidate list\" for \\(Q_{x+1}\\). Once the current round of deletions is complete, we check each element to determine if it should be added in \\(Q_{x+1}\\). This process continues until \\(Q_x\\) is empty.","link":"/tutorials/index.html"},{"title":"About","text":"‚≠êÔ∏èHi! I am Hong Zhaoyang, a third-year undergraduate from the Southern University of Science and Technology (SUSTech) in Shenzhen, China. I am currently conducting research on vector databases (VDB) for large language models (LLMs) in the SUSTech DBGroup under the guidance of Prof. Bo Tang. I plan to apply for a CS PhD program for admission in Fall 2026. I have a keen interest in system design and mechanisms. I also enjoy socializing and collaborating with others. Feel free to contact me! Awards 2022-2023: 47th ICPC (International College Programming Contest) World Finalist (Top 1%) (Qualification Regional) 2023-2024: 9th CCPC (Chinese College Programming Contest) Regional 2-nd runner-up (Scoreboard) 2024: SIGMOD Programming Contest World Finalist (Dashboard) See more repetitive awards here Publications Yangshen Deng, Shiwen Chen, Zhaoyang Hong, Bo Tang. How Does Software Prefetching Work on GPU Query Processing? 20th International Workshop on Data Management on New Hardware (DaMoN), affiliated with SIGMOD , Santiago, Chile, June 2024. Experiences Student Assistant of CS209 Introduction to Java Programming, Fall 2023 Student Assistant of CS203 Data Structures and Algorithm Analysis, Fall 2024 (English-speaking) Student Coach of SUSTech-CPC Competition Team, 2022-2023 Problem Setter and Organizer of 2023 SUSTech Programming Competition (Involving 200+ participants from 10+ schools) Instructor of the Voluntary Courses in Olympic in Informatics (OI) for The High school Affiliated to Southern University of Science and Technology (HSAS), 2023 Summer Instructor of X-Camp Summer Camp, 2024 Summer (Hangzhou, China)","link":"/about/index.html"}]}